{\rtf1\ansi\ansicpg1252\cocoartf2820
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 CourierNewPSMT;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww30200\viewh23660\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \
def 
\fs34 char_exist
\fs24 (s1, s2):\
    d = \{\}\
    for char in s1:\
        d[char] = 1\
    print(d)\
    for char in s2:\
        if char not in d:\
            return False\
    return True\
\
def 
\fs34 fizz_buzz
\fs24 (n):\
    if n % 15 == 0:\
        return str(n) + " FizzBuzz"\
    elif n % 3 == 0:\
        return str(n) + " Fizz"\
    elif n % 5 == 0:\
        return str(n) + " Buzz"\
    else:\
        return int(n)\
def fizz_buzz_list(n):\
    for i in range(1, n + 1):\
        print(fizz_buzz(i))\
\
def 
\fs34 is_palendrome
\fs24 (s):\
    return s == s[::-1]\
\
\
def 
\fs34 check_paren(string)
\fs24 :\
    stack = []  # stack push and pop Found Parentheses\
    for char in string:\
        if char == "(":\
            stack.append(char)\
        elif char == ")":  # if closing paren\
            if not stack:\
                return False  # not balanced\
            stack.pop()  # if stack has a paren, pop it\
    return not stack  # Does stack have nothing in it? If yes, it is balanced\
\
def 
\fs34 sum_all_multiples
\fs24 (n, m, p):\
    sum = 0\
    for i in range(1, n):\
        if i % m == 0 or p % 5 == 0:\
            sum += i\
    return sum\
\
def 
\fs34 count_occurrences(list)
\fs24 :\
    count_dict = \{\}\
    for item in list:\
        count_dict[item] = count_dict.get(item, 0) + 1\
    return count_dict\
\
def 
\fs34 fibonacci(n)
\fs24 :\
    a, b = 0, 1\
    for i in range(n):\
        print(a)\
        a, b = b, a + b\
\
def 
\fs34 reverse(n, k)
\fs24 :\
    n = str(n)\
    n = n[:k] + n[k:][::-1]\
    return int(n)\
\
def 
\fs34 reverse_at_k(l, k)
\fs24 :\
    return l[:k] + l[k:][::-1]\
\
def 
\fs34 merge_sort_lists(l1, l2)
\fs24 :\
    return sorted(l1 + l2)\
\
def 
\fs34 find_dupes_with_nums
\fs24 (lst):  # returns indexes and the duplicated value\
    seen = \{\}\
    for i, item in enumerate(lst):\
        if item in seen:\
            return seen[item], i, item\
        seen[item] = i\
    return None\
\
def 
\fs34 get_longest_sublist
\fs24 (lst):\
    longest_sublist = []\
    current_sublist = []\
    for i in range(len(lst) - 1):\
        if lst[i] == lst[i + 1]:\
            current_sublist.append(lst[i])\
        else:\
            current_sublist.append(lst[i])\
            if len(current_sublist) > len(longest_sublist):\
                longest_sublist = current_sublist\
            current_sublist = []\
    return longest_sublist\
\
def 
\fs34 rotate_list
\fs24 (l, k):\
    n = len(l)\
    k = k % n\
    return l[-k:] + l[:-k]\
\
def 
\fs34 find_missing
\fs24 (arr):\
    n = len(arr)\
    total = (n + 1) * (n + 2) // 2\
    for i in arr:\
        total -= i\
    return total\
\
# 
\fs34 Inorder
\fs24  Traversal\
def inorder_traversal(root):\
    if root:\
        inorder_traversal(root.left)\
        print(root.data, end=" ")\
        inorder_traversal(root.right)\
\
\
# 
\fs34 Preorder
\fs24  Traversal\
def preorder_traversal(root):\
    if root:\
        print(root.data, end=" ")\
        preorder_traversal(root.left)\
        preorder_traversal(root.right)\
\
\
# 
\fs34 Postorder
\fs24  Traversal\
def postorder_traversal(root):\
    if root:\
        postorder_traversal(root.left)\
        postorder_traversal(root.right)\
        print(root.data, end=" ")\
\
def 
\fs34 find_max_depth
\fs24 (root):  # Return tree depth\
    if root is None:  # Base Case\
        return 0\
    else:  # Recursively count every node\
        left_depth = find_max_depth(root.left)\
        right_depth = find_max_depth(root.right)\
\
        if left_depth > right_depth:\
            return left_depth + 1\
        else:\
            return right_depth + 1\
\
def 
\fs34 find_lca
\fs24 (root, node1, node2):\
    if root is None:  # Base Case\
        return None\
    if root.data == node1 or root.data == node2:  # find a root?\
        return root  # return it\
    left = find_lca(root.left, node1, node2)  # recursively search left\
    right = find_lca(root.right, node1, node2)  # recursively search right\
    if left and right:\
        return root\
    if left is None and right is None:\
        return None\
    return left if left else right\
\
def 
\fs34 bfs
\fs24 (root):\
    result = []\
    if not root:  				# If the tree is empty, return an empty list\
        return result\
    queue = [root]  			# Initialize a queue with the root node\
    while queue:\
        level = []  				# Initialize a list to store the nodes at current level\
        for _ in range(len(queue)):\
            node = queue.pop(0)  			# Dequeue the first node from the queue\
            level.append(node.value)  		# Add the node's value to the current level\
            if node.left:  				# Enqueue the left child if it exists\
                queue.append(node.left)\
            if node.right:  				# Enqueue the right child if it exists\
                queue.append(node.right)\
        result.append(level)  			# Add the current level to the result list\
    return result\
\
def 
\fs34 selection_sort(list)
\fs24 :\
    n = len(list)\
    for i in range(n):\
        min_idx = i\
        for j in range(i + 1, n):\
            if list[min_idx] > list[j]:\
                min_idx = j\
        list[i], list[min_idx] = list[min_idx], list[i]\
\
def 
\fs34 insertion_sort(arr)
\fs24 :\
    for i in range(1, len(arr)):\
        key = arr[i]\
        j = i - 1\
        while j >= 0 and key < arr[j]:\
            arr[j + 1] = arr[j]\
            j -= 1\
        arr[j + 1] = key\
\
def 
\fs34 merge_sort(arr)
\fs24 :\
    if len(arr) > 1:\
        mid = len(arr) // 2\
        left_half = arr[:mid]\
        right_half = arr[mid:]\
\
        merge_sort(left_half)\
        merge_sort(right_half)\
\
        i = j = k = 0\
\
        while i < len(left_half) and j < len(right_half):\
            if left_half[i] < right_half[j]:\
                arr[k] = left_half[i]\
                i += 1\
            else:\
                arr[k] = right_half[j]\
                j += 1\
            k += 1\
\
        while i < len(left_half):\
            arr[k] = left_half[i]\
            i += 1\
            k += 1\
\
        while j < len(right_half):\
            arr[k] = right_half[j]\
            j += 1\
            k += 1\
\
def 
\fs34 quick_sort(arr)
\fs24 :\
    for i in range(len(arr)):\
        for j in range(i + 1, len(arr)):\
            if arr[i] > arr[j]:\
                arr[i], arr[j] = arr[j], arr[i]\
\
def 
\fs34 two_sum
\fs24 (arr, target):\
    discovered = \{\}\
    for i, num in enumerate(arr):\
        if target - num in discovered:\
            return [discovered[target - num], i]\
        discovered[num] = i\
    return None\
\
def 
\fs34 two_sum_pointers
\fs24 (arr, target):\
    left, right = 0, len(arr) - 1\
    while left < right:\
        if arr[left] + arr[right] == target: \
            return [left, right]\
        elif arr[left] + arr[right] < target: \
            left += 1\
        else:\
            right -= 1\
    return None\
\
def 
\fs34 quick_k_select(list, k)
\fs24 :\
    if list:\
        pivot = list[0]  # choose the first element as the pivot\
        less = [x for x in list if x < pivot]  # elements less than the pivot\
        greater = [x for x in list if x > pivot]  # elements greater than the pivot\
        equal = [x for x in list if x == pivot]  # elements equal to the pivot\
\
        if k <= len(greater):\
            return quick_k_select(greater, k)\
        elif k <= len(greater) + len(equal):\
            return pivot\
        else:\
            return quick_k_select(less, k - len(greater) - len(equal))\
\
def 
\fs34 move_zeros(nums)
\fs24 :\
    p1 = 0\
    p2 = 0\
\
    while p2 < len(nums):\
        if nums[p2] != 0:\
            nums[p1], nums[p2] = nums[p2], nums[p1]\
            p1 += 1\
        p2 += 1\
\
    return nums\
\
def 
\fs34 group_anagrams(strs)
\fs24 :\
    anagrams = \{\}\
    for s in strs:\
        sorted_s = "".join(sorted(s))\
        if sorted_s in anagrams:\
            anagrams[sorted_s].append(s)\
        else:\
            anagrams[sorted_s] = [s]\
\
    return list(anagrams.values())\
\
def 
\fs34 count_islands(grid)
\fs24 :\
    if not grid:\
        return 0\
\
    rows = len(grid)\
    cols = len(grid[0])\
    count = 0\
\
    def dfs(i, j):\
        if 0 <= i:\
            if i < rows:\
                if 0 <= j:\
                    if j < cols:\
                        if grid[i][j] == 1:\
                            grid[i][j] = 0\
                            dfs(i - 1, j)\
                            dfs(i + 1, j)\
                            dfs(i, j - 1)\
                            dfs(i, j + 1)\
\
    for i in range(rows):\
        for j in range(cols):\
            if grid[i][j] == 1:\
                dfs(i, j)\
                count += 1\
\
    return count\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\
def 
\fs34 bubble_sort(list)
\fs24 :\
    n = len(list)\
    for i in range(n):\
        for j in range(0, n - i - 1):\
            if list[j] > list[j + 1]:\
                list[j], list[j + 1] = list[j + 1], list[j]\
}